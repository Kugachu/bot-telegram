Пишем TG бота на JS

1) Инициализируем node js через npm init -y
2) Создаем index.js, после создания node js появится package.json со всей информацией о используемых библиотеках (зависимостей)

Основная работа будет в index.js

3) Создаем пременную и помещаем в нее наш персональный токен от TG
4) Установим библиотеку npm node-telegram-bot-api nodemon. Через нее мы будет взаимодействовать с API TG
5) nodemon - автоматически перезагружает сервер после любых изменений в коде. Полезная библиотека.

6) Испортируем пакет node-telegram-bot-api через require('...СЮДА посметить название библиотеки...'). Через него мы будем создавать экземпляр класа
    В Package.json убедиться, что зависимости установились и библиотека действительно импортирована

7) В Package.json напишем скрипт (конкретно в свойстве scripts). Укажем в значении dev режим разработки nodemon index.js.
    Второй скрипт start указать значением node index.js -> для продакшена, через него выполняется файл index.js

Создание экземпляра бота
8) через new создаем экземпляр класса, в качестве параметров первым идет на токен, а вторые и последующие параметры указывать не обязательно (опциональные)
    В нашем случае, передадим дополнительный параметр polling по значением true.

Запуск бота
9) В консоли прописать npm run dev, перейти в бота в TG и нажать "запустить"

Работа с функционалом
10) создаем слушатель события для обработки полученных сообщений. Прописывать как метод у экземпляра класса TelegramApi. Проверить, что все работает.
    Слушатель события при принимает два параметра, первый - тип данных, второй - функция в качестве колбэка для обработки входящего сообщения.

    Событие представляет из себя объект со свойствами и значениями, которые можно обрабатывать по-отдельности.

11) Из полученного слушателя события достанем текст сообщения и ID чата.
12) Отправим сообщение от бота пользователю через соответствующий метод, Первый параметр - id чата, второй - текст, который надо отправить.

13) Можно написать логику обработки входящего сообщения от бота, когда юзер первый раз запустил бота.
Для этого через if проверяем отправку пользователем слова '/start', если условие true - выводить сообщение от бота.

14) В чате боту можно отправлять определенные команды, которые начинаются на '/'. Например '/info', '/start'

15) Пусть при первом запуске бот отправляет нам стикер. Делаем это через sendSticker(). Первый параметр - id чата, второй - ссылка на стикер

16) Все функции являются асинхронными - поэтому, перед вызовом каждой из функций, указывать await

17) Укажем явно, какие функции есть у бота через setMyCommands() - принимает массив объектов, где один объект - это конктретная функция бота. Каждый объект имеет два свойства: первое - command название команды, второе - описание description.

    Как результат, в TG появится список доступных команд

Работа со структурой проекта
18) Создадим функцию Start, в нее поместим весь наш код с обработкой сообщения. Делаем это для того, чтобы бот мог отвечать на несуществующие команды от пользователя. Некоторые await заменяем на return. Если ни одно из условий не выполнено, бот вернет сообщение, что он нас не понимает

19) Напишем команду, после которй бот загадает нам число, а мы будет его отгадывать. Используем библиотеку Math для вызова функции random(), она вернет случайной число от 0 до 10 с плавающей запятой, поэтому умножаем еще на 10. оборачиваем результат в функцию floor(), чтобы округлить результат до целого числа.

20) Поместим полученное случайное число в созданный объект для хранения чисел. Ключем будет id чата, а значением - полученное рандомное число.

Работа с кнопками
21) Метод sendMessage() третьим параметром принимает объект form, который будет нашей кнопкой, которая отправится вместе с сообщением от бота, чтобы пользователь мог ответить нажав на кнопку.

22) Создим переменную, в которую поместим объект, который будет иметь единственное поле reply_markup, а значение этого поля будет преобразование в json-строку (JSON.stringfy()), таким образом, через этот метод объект преобразуется в строку. Внутри stringfy() поместить объект к полем inline_keyboard, который имеет в качесвте значения массив [], который хранит в себе массив одной кнопки. В массиве кнопки лежит объект кнопки с послем text и callback_data. callback_data - это ответ, который пользователь пошлет, если нажмет на кнопку

23) Передать созданный объект с копками третьим параметром в sendMessage()

24) Создадим слушатель события, который будет проверять правильность выбора кнопки. Первым параметром on() будет event 'callback_query', воторой параметр - callback-сообщение. 

25) Из этого слушателя вытащим после data и id чата и выведем сообщение от бота, какую цифру выбрал пользователь

26) Создадим форму с кнопками. Сейчас они расположены в ряд, можно сделать в столбец, чтобы не занимало много места. Каждый вложенный массив - это отдельная строка (преобразована через JSON.stringfy).

27) Сделаем проверку, отгадал ли пользователь число или нет.

28) В слушателе события, когда юзер нажал на кнопку, проверяем через if, что число равно числу из объекта, в который было помещено рандомное число.

29) Добавим кнопку, которая спросит, хотим ли мы сыграть еще раз. Аналогично создаем кнопку. В качестве колбэка указать команду '/again'

30) Создаем команду '/again' и помещаем в список доступных команд. Если условие '/again' true, то вызывать функцию загадывания числа и записи ее в объект. Вынесем эту логику в отдельную функцию, чтобы код не дублировался

31) В эту стрелочную асинхронную функцию передать параметр id чата. В нужных местах вызываем новую функцию для старта игры.

32) Создадим отдельный файл для кнопок, чтобы упростить чтение кода. В новом файле через module.exports переносим код с кнопками. Так как теперь это элементы объекта, убираем const и = меняем на :

33) Теперь импортируем кнопки из нового файла в index.js

Деплой бота на сервер, чтобы он работал не останавливаясь
34) Для начала загитим бота. Создаем gitignore. Указывам /node_modules и .idea 
    Заходим на github и создаем репозиторий.  Копируем git-romote для создания ссылки на удаленный репозиторий.
    Инициализируем в терминале get init

Подключение к БД
32) 